function gcd(m,n)
{
for(let i=Math.max(m,n); i>=1; i-=1)
{
	if(m%i==0 && n%i==0)
	{
		return i;
	}
}
	//At least 1 will divide both
}

function phi(n)
{
	let counter=0;
	for(let i=1; i<=n; i++)
	{
		if(gcd(i,n)==1)
		{
			counter++;
		}
	}
	return counter;
}


 function generateMultiplicativeGroup(generator,modulus) {
	list=[];
	let at=generator
	for(let i=0; at!=1; at=(at*generator)%modulus,i++) {

		list[i]=at;
		
	}
	list.push(1);
		return list;
}

function generateAdditiveGroup(generator,modulus) {
	list=[];
	let at = generator;
	for(let i=0; at!=0;at=(at+generator)%modulus,i++)
	{
		list[i]=at;
	}
	list.push(0);
	return list;
}


function mod(data,modulus) {
	let newData =[];
	for(let i=0; i<data.length; i++)
	{
		newData[i]=data[i]%modulus;
	}
	return newData;
}

function distribution(data,modulus) {
	let dist=[];
	for (let value=0; value<modulus; value++) 
	{
		valueCounter=0;
		for (i=0; i<data.length; i++) {
			if(value==data[i])
			{
				valueCounter++;
			}
		}
		dist[value]=valueCounter;
	}
	return dist;
}

function newOrder(indices,Data) {
	let data=[];
	for (let i=0; i<indices.length; i++)
	{
		data[i]=Data[indices[i]];
	}
	return data;
}


function primitiveGenerator(n) {

for(let i=1; i<n; i++) {                //generates relative primes
	var myGroup=generateMultiplicativeGroup(i,n);
	if(myGroup.length==phi(n))
	{
		return i;
	}
}
return(0);
}

function factorPower(generator,num,modulus) //generator must generate the relative primes and num must be relatively prime to modulus
{
	counter=1;
	for(i=0; i<modulus; i++)
	{
		if(counter==num)
		{
			return i;
		}

		counter=counter*generator%modulus;
	}
}

function cosetGenerator(num,modulus) {  //num has to be relatively prime to modulus
	let originalCoset=generateMultiplicativeGroup(num,modulus);
	let numberOfRelPrimes=phi(modulus);
	let generator=primitiveGenerator(modulus);
	let k = factorPower(generator,num,modulus);
	let cosetRepresentatives=[1];
	let GCD=gcd(k,modulus);

	counter=1;
	for(let i=1; i<gcd(k,numberOfRelPrimes); i++)                        //Each of these powers of generator is a unique coset representative with respect to the groum generated by num.
	{
		counter=counter*generator%modulus;
		cosetRepresentatives.push(counter);                                                  
	}

	let cosets=new Array();
	for(let i=0; i<cosetRepresentatives.length; i++)
	{
		let coset=new Array();
		for(j=0; j<originalCoset.length; j++)
		{
			let newElement=cosetRepresentatives[i]*originalCoset[j]%modulus;                      //Each coset is a unique coset representative times the group generated by num.
			coset.push(newElement);
		}
		cosets.push(coset);
	}
	return cosets;
}
